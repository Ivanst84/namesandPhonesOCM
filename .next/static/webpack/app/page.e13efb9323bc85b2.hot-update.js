"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/generateMessage.ts":
/*!*************************************!*\
  !*** ./src/util/generateMessage.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateMessage: function() { return /* binding */ generateMessage; }\n/* harmony export */ });\n// Función para mezclar el orden de los paquetes de forma aleatoria\nvar generateRandomOrder = function(packages) {\n    for(var i = packages.length - 1; i > 0; i--){\n        var j = Math.floor(Math.random() * (i + 1));\n        var ref;\n        ref = [\n            packages[j],\n            packages[i]\n        ], packages[i] = ref[0], packages[j] = ref[1], ref;\n    }\n    return packages.join(\"\\n\");\n};\n// Función para generar un nombre de marca aleatorio\nvar randomBrandName = function() {\n    var brandVariations = [\n        \"izzi\",\n        \"izz!\",\n        \"izi\",\n        \"iz!!\"\n    ];\n    return brandVariations[Math.floor(Math.random() * brandVariations.length)];\n};\n// Función para generar introducciones aleatorias\nvar randomIntroduction = function(name, salesPersonName) {\n    var introductions = [\n        \"\\uD83C\\uDF1F \\xa1Hola \".concat(name, \"! \\uD83C\\uDF1F\\nTe saluda \").concat(salesPersonName || \"un asesor de \".concat(randomBrandName()), \",\"),\n        \"\\uD83C\\uDF89 \\xa1Qu\\xe9 tal, \".concat(name, \"! \\uD83C\\uDF89\\nSoy \").concat(salesPersonName || \"un representante de \".concat(randomBrandName()), \",\"),\n        \"\\uD83D\\uDCE2 \\xa1Saludos, \".concat(name, \"! \\uD83D\\uDCE2\\nAqu\\xed \").concat(salesPersonName || \"desde \".concat(randomBrandName()), \",\"),\n        \"✨ \\xa1Hola \".concat(name, \"! ✨\\nMi nombre es \").concat(salesPersonName || \"y soy parte de \".concat(randomBrandName()), \",\")\n    ];\n    return introductions[Math.floor(Math.random() * introductions.length)];\n};\n// Función principal\nvar generateMessage = function(name, salesPersonName, messageType, customMessage) {\n    // Si el mensaje es personalizado, lo retornamos con nombre y asesor\n    if (messageType === \"Personalizado\") {\n        return \"\\uD83C\\uDF1F \\xa1Hola \".concat(name, \"! \\uD83C\\uDF1F\\n\").concat(customMessage, \"\\n\\nAtentamente, \").concat(salesPersonName || \"Asesor de \".concat(randomBrandName()));\n    }\n    // Paquetes de precios para los mensajes predefinidos\n    var packagesClientes = [\n        \"\\uD83D\\uDCF6 Internet 100 megas: $369\",\n        \"\\uD83D\\uDCFA Internet 80 megas + Cable: $489\",\n        \"\\uD83D\\uDCE1 Internet 100 megas + 100 canales: $519\"\n    ];\n    var packagesNuevos = [\n        \"\\uD83D\\uDCE1 Solo Internet: 100 megas por $369\",\n        \"\\uD83D\\uDCFA Internet + TV: 80 megas por $489\",\n        \"\\uD83D\\uDCE1 100 megas de Internet + 100 canales por $519\",\n        \"\\uD83D\\uDCF6internet +Netfli + streaming 100 canales por $519\"\n    ];\n    // Generar el orden aleatorio de los paquetes\n    var shuffledClientesPackages = generateRandomOrder(packagesClientes);\n    var shuffledNuevosPackages = generateRandomOrder(packagesNuevos);\n    // Variar también las frases finales/despedidas\n    var despedidas = [\n        \"\\xa1No pierdas esta oportunidad!\",\n        \"\\xa1Aprovecha ahora y cont\\xe1ctame!\",\n        \"Estoy aqu\\xed para resolver tus dudas.\",\n        \"Quedo atento.\"\n    ];\n    var randomDespedida = function() {\n        return despedidas[Math.floor(Math.random() * despedidas.length)];\n    };\n    // Mensajes predefinidos para Clientes y Nuevos\n    var clienteMessages = [\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\nActualmente, sabemos que est\\xe1s pagando el precio regular. \\xa1Pero tenemos promociones para ti! Aqu\\xed te dejo algunas opciones:\\n\\n\").concat(shuffledClientesPackages, \"\\n\\n\").concat(randomDespedida()),\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\nHemos revisado tu cuenta y podemos ofrecerte estas promociones:\\n\\n\").concat(shuffledClientesPackages, \"\\n\\n\").concat(randomDespedida()),\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\n\\xa1No te pierdas nuestras nuevas ofertas! Aqu\\xed te dejo las opciones disponibles:\\n\\n\").concat(shuffledClientesPackages, \"\\n\\n\").concat(randomDespedida())\n    ];\n    var nuevosMessages = [\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\nEstamos emocionados de ofrecerte estas promociones exclusivas:\\n\\n\").concat(shuffledNuevosPackages, \"\\n\\n\").concat(randomDespedida()),\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\n\\xa1Te tenemos una oferta especial! Aqu\\xed tienes nuestras promociones:\\n\\n\").concat(shuffledNuevosPackages, \"\\n\\n\").concat(randomDespedida()),\n        \"\".concat(randomIntroduction(name, salesPersonName), \"\\n\\nNos encantar\\xeda que aproveches nuestras ofertas. Aqu\\xed tienes las opciones:\\n\\n\").concat(shuffledNuevosPackages, \"\\n\\n\").concat(randomDespedida())\n    ];\n    // Selecciona aleatoriamente un mensaje de los arrays predefinidos\n    switch(messageType){\n        case \"Clientes\":\n            return clienteMessages[Math.floor(Math.random() * clienteMessages.length)];\n        case \"Nuevos\":\n            return nuevosMessages[Math.floor(Math.random() * nuevosMessages.length)];\n        default:\n            return clienteMessages[Math.floor(Math.random() * clienteMessages.length)];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL2dlbmVyYXRlTWVzc2FnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbUVBQW1FO0FBQ25FLElBQU1BLHNCQUFzQixTQUFDQztJQUMzQixJQUFLLElBQUlDLElBQUlELFNBQVNFLE1BQU0sR0FBRyxHQUFHRCxJQUFJLEdBQUdBLElBQUs7UUFDNUMsSUFBTUUsSUFBSUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQU1MLENBQUFBLElBQUk7O2NBQ2I7WUFBQ0QsUUFBUSxDQUFDRyxFQUFFO1lBQUVILFFBQVEsQ0FBQ0MsRUFBRTtTQUFDLEVBQXRERCxRQUFRLENBQUNDLEVBQUUsV0FBRUQsUUFBUSxDQUFDRyxFQUFFO0lBQzNCO0lBQ0EsT0FBT0gsU0FBU08sSUFBSSxDQUFDO0FBQ3ZCO0FBRUEsb0RBQW9EO0FBQ3BELElBQU1DLGtCQUFrQjtJQUN0QixJQUFNQyxrQkFBa0I7UUFBQztRQUFRO1FBQVE7UUFBTztLQUFPO0lBQ3ZELE9BQU9BLGVBQWUsQ0FBQ0wsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtHLGdCQUFnQlAsTUFBTSxFQUFFO0FBQzVFO0FBRUEsaURBQWlEO0FBQ2pELElBQU1RLHFCQUFxQixTQUFDQyxNQUFjQztJQUN4QyxJQUFNQyxnQkFBZ0I7UUFDbkIseUJBQWtDRCxPQUF2QkQsTUFBSyw4QkFBeUUsT0FBdkRDLG1CQUFtQixnQkFBa0MsT0FBbEJKLG9CQUFvQjtRQUN6RixnQ0FBZ0NJLE9BQWpCRCxNQUFLLHdCQUEwRSxPQUE5REMsbUJBQW1CLHVCQUF5QyxPQUFsQkosb0JBQW9CO1FBQzlGLDZCQUFpQ0ksT0FBbEJELE1BQUssNEJBQTZELE9BQWhEQyxtQkFBbUIsU0FBMkIsT0FBbEJKLG9CQUFvQjtRQUNqRixjQUFtQ0ksT0FBekJELE1BQUssc0JBQTZFLE9BQXpEQyxtQkFBbUIsa0JBQW9DLE9BQWxCSixvQkFBb0I7S0FDOUY7SUFDRCxPQUFPSyxhQUFhLENBQUNULEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLTyxjQUFjWCxNQUFNLEVBQUU7QUFDeEU7QUFFQSxvQkFBb0I7QUFDYixJQUFNWSxrQkFBa0IsU0FDN0JILE1BQ0FDLGlCQUNBRyxhQUNBQztJQUVBLG9FQUFvRTtJQUNwRSxJQUFJRCxnQkFBZ0IsaUJBQWlCO1FBQ25DLE9BQU8seUJBQXlCQyxPQUFiTCxNQUFLLG9CQUF5Q0MsT0FBakNJLGVBQWMscUJBQXVFLE9BQXBESixtQkFBbUIsYUFBK0IsT0FBbEJKO0lBQ25HO0lBRUEscURBQXFEO0lBQ3JELElBQU1TLG1CQUFtQjtRQUN0QjtRQUNBO1FBQ0E7S0FDRjtJQUVELElBQU1DLGlCQUFpQjtRQUNwQjtRQUNBO1FBQ0E7UUFDQTtLQUVGO0lBRUQsNkNBQTZDO0lBQzdDLElBQU1DLDJCQUEyQnBCLG9CQUFvQmtCO0lBQ3JELElBQU1HLHlCQUF5QnJCLG9CQUFvQm1CO0lBRW5ELCtDQUErQztJQUMvQyxJQUFNRyxhQUFhO1FBQ2pCO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxJQUFNQyxrQkFBa0I7ZUFBTUQsVUFBVSxDQUFDakIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtlLFdBQVduQixNQUFNLEVBQUU7O0lBRXZGLCtDQUErQztJQUMvQyxJQUFNcUIsa0JBQWtCO1FBQ3JCLEdBQWlMSixPQUEvS1QsbUJBQW1CQyxNQUFNQyxrQkFBaUIsZ0pBQW9LVSxPQUEvQkgsMEJBQXlCLFFBQXdCLE9BQWxCRztRQUNoTixHQUFxSEgsT0FBbkhULG1CQUFtQkMsTUFBTUMsa0JBQWlCLDJFQUF3R1UsT0FBL0JILDBCQUF5QixRQUF3QixPQUFsQkc7UUFDcEosR0FBb0lILE9BQWxJVCxtQkFBbUJDLE1BQU1DLGtCQUFpQixnR0FBdUhVLE9BQS9CSCwwQkFBeUIsUUFBd0IsT0FBbEJHO0tBQ3JLO0lBRUQsSUFBTUUsaUJBQWlCO1FBQ3BCLEdBQW9ISixPQUFsSFYsbUJBQW1CQyxNQUFNQyxrQkFBaUIsMEVBQXFHVSxPQUE3QkYsd0JBQXVCLFFBQXdCLE9BQWxCRTtRQUNqSixHQUF3SEYsT0FBdEhWLG1CQUFtQkMsTUFBTUMsa0JBQWlCLG9GQUF5R1UsT0FBN0JGLHdCQUF1QixRQUF3QixPQUFsQkU7UUFDckosR0FBK0hGLE9BQTdIVixtQkFBbUJDLE1BQU1DLGtCQUFpQiwyRkFBZ0hVLE9BQTdCRix3QkFBdUIsUUFBd0IsT0FBbEJFO0tBQzlKO0lBRUQsa0VBQWtFO0lBQ2xFLE9BQVFQO1FBQ04sS0FBSztZQUNILE9BQU9RLGVBQWUsQ0FBQ25CLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLaUIsZ0JBQWdCckIsTUFBTSxFQUFFO1FBQzVFLEtBQUs7WUFDSCxPQUFPc0IsY0FBYyxDQUFDcEIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtrQixlQUFldEIsTUFBTSxFQUFFO1FBQzFFO1lBQ0UsT0FBT3FCLGVBQWUsQ0FBQ25CLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLaUIsZ0JBQWdCckIsTUFBTSxFQUFFO0lBQzlFO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbC9nZW5lcmF0ZU1lc3NhZ2UudHM/MjI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGdW5jacOzbiBwYXJhIG1lemNsYXIgZWwgb3JkZW4gZGUgbG9zIHBhcXVldGVzIGRlIGZvcm1hIGFsZWF0b3JpYVxuY29uc3QgZ2VuZXJhdGVSYW5kb21PcmRlciA9IChwYWNrYWdlczogc3RyaW5nW10pOiBzdHJpbmcgPT4ge1xuICBmb3IgKGxldCBpID0gcGFja2FnZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICBbcGFja2FnZXNbaV0sIHBhY2thZ2VzW2pdXSA9IFtwYWNrYWdlc1tqXSwgcGFja2FnZXNbaV1dO1xuICB9XG4gIHJldHVybiBwYWNrYWdlcy5qb2luKCdcXG4nKTtcbn07XG5cbi8vIEZ1bmNpw7NuIHBhcmEgZ2VuZXJhciB1biBub21icmUgZGUgbWFyY2EgYWxlYXRvcmlvXG5jb25zdCByYW5kb21CcmFuZE5hbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGJyYW5kVmFyaWF0aW9ucyA9IFsnaXp6aScsICdpenohJywgJ2l6aScsICdpeiEhJ107XG4gIHJldHVybiBicmFuZFZhcmlhdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYnJhbmRWYXJpYXRpb25zLmxlbmd0aCldO1xufTtcblxuLy8gRnVuY2nDs24gcGFyYSBnZW5lcmFyIGludHJvZHVjY2lvbmVzIGFsZWF0b3JpYXNcbmNvbnN0IHJhbmRvbUludHJvZHVjdGlvbiA9IChuYW1lOiBzdHJpbmcsIHNhbGVzUGVyc29uTmFtZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGludHJvZHVjdGlvbnMgPSBbXG4gICAgYPCfjJ8gwqFIb2xhICR7bmFtZX0hIPCfjJ9cXG5UZSBzYWx1ZGEgJHtzYWxlc1BlcnNvbk5hbWUgfHwgYHVuIGFzZXNvciBkZSAke3JhbmRvbUJyYW5kTmFtZSgpfWB9LGAsXG4gICAgYPCfjokgwqFRdcOpIHRhbCwgJHtuYW1lfSEg8J+OiVxcblNveSAke3NhbGVzUGVyc29uTmFtZSB8fCBgdW4gcmVwcmVzZW50YW50ZSBkZSAke3JhbmRvbUJyYW5kTmFtZSgpfWB9LGAsXG4gICAgYPCfk6IgwqFTYWx1ZG9zLCAke25hbWV9ISDwn5OiXFxuQXF1w60gJHtzYWxlc1BlcnNvbk5hbWUgfHwgYGRlc2RlICR7cmFuZG9tQnJhbmROYW1lKCl9YH0sYCxcbiAgICBg4pyoIMKhSG9sYSAke25hbWV9ISDinKhcXG5NaSBub21icmUgZXMgJHtzYWxlc1BlcnNvbk5hbWUgfHwgYHkgc295IHBhcnRlIGRlICR7cmFuZG9tQnJhbmROYW1lKCl9YH0sYCxcbiAgXTtcbiAgcmV0dXJuIGludHJvZHVjdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaW50cm9kdWN0aW9ucy5sZW5ndGgpXTtcbn07XG5cbi8vIEZ1bmNpw7NuIHByaW5jaXBhbFxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlTWVzc2FnZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBzYWxlc1BlcnNvbk5hbWU6IHN0cmluZyxcbiAgbWVzc2FnZVR5cGU6IHN0cmluZyxcbiAgY3VzdG9tTWVzc2FnZTogc3RyaW5nXG4pOiBzdHJpbmcgPT4ge1xuICAvLyBTaSBlbCBtZW5zYWplIGVzIHBlcnNvbmFsaXphZG8sIGxvIHJldG9ybmFtb3MgY29uIG5vbWJyZSB5IGFzZXNvclxuICBpZiAobWVzc2FnZVR5cGUgPT09ICdQZXJzb25hbGl6YWRvJykge1xuICAgIHJldHVybiBg8J+MnyDCoUhvbGEgJHtuYW1lfSEg8J+Mn1xcbiR7Y3VzdG9tTWVzc2FnZX1cXG5cXG5BdGVudGFtZW50ZSwgJHtzYWxlc1BlcnNvbk5hbWUgfHwgYEFzZXNvciBkZSAke3JhbmRvbUJyYW5kTmFtZSgpfWB9YDtcbiAgfVxuXG4gIC8vIFBhcXVldGVzIGRlIHByZWNpb3MgcGFyYSBsb3MgbWVuc2FqZXMgcHJlZGVmaW5pZG9zXG4gIGNvbnN0IHBhY2thZ2VzQ2xpZW50ZXMgPSBbXG4gICAgYPCfk7YgSW50ZXJuZXQgMTAwIG1lZ2FzOiAkMzY5YCxcbiAgICBg8J+TuiBJbnRlcm5ldCA4MCBtZWdhcyArIENhYmxlOiAkNDg5YCxcbiAgICBg8J+ToSBJbnRlcm5ldCAxMDAgbWVnYXMgKyAxMDAgY2FuYWxlczogJDUxOWAsXG4gIF07XG5cbiAgY29uc3QgcGFja2FnZXNOdWV2b3MgPSBbXG4gICAgYPCfk6EgU29sbyBJbnRlcm5ldDogMTAwIG1lZ2FzIHBvciAkMzY5YCxcbiAgICBg8J+TuiBJbnRlcm5ldCArIFRWOiA4MCBtZWdhcyBwb3IgJDQ4OWAsXG4gICAgYPCfk6EgMTAwIG1lZ2FzIGRlIEludGVybmV0ICsgMTAwIGNhbmFsZXMgcG9yICQ1MTlgLFxuICAgIGDwn5O2aW50ZXJuZXQgK05ldGZsaSArIHN0cmVhbWluZyAxMDAgY2FuYWxlcyBwb3IgJDUxOWAsXG5cbiAgXTtcblxuICAvLyBHZW5lcmFyIGVsIG9yZGVuIGFsZWF0b3JpbyBkZSBsb3MgcGFxdWV0ZXNcbiAgY29uc3Qgc2h1ZmZsZWRDbGllbnRlc1BhY2thZ2VzID0gZ2VuZXJhdGVSYW5kb21PcmRlcihwYWNrYWdlc0NsaWVudGVzKTtcbiAgY29uc3Qgc2h1ZmZsZWROdWV2b3NQYWNrYWdlcyA9IGdlbmVyYXRlUmFuZG9tT3JkZXIocGFja2FnZXNOdWV2b3MpO1xuXG4gIC8vIFZhcmlhciB0YW1iacOpbiBsYXMgZnJhc2VzIGZpbmFsZXMvZGVzcGVkaWRhc1xuICBjb25zdCBkZXNwZWRpZGFzID0gW1xuICAgIFwiwqFObyBwaWVyZGFzIGVzdGEgb3BvcnR1bmlkYWQhXCIsXG4gICAgXCLCoUFwcm92ZWNoYSBhaG9yYSB5IGNvbnTDoWN0YW1lIVwiLFxuICAgIFwiRXN0b3kgYXF1w60gcGFyYSByZXNvbHZlciB0dXMgZHVkYXMuXCIsXG4gICAgXCJRdWVkbyBhdGVudG8uXCIsXG4gIF07XG4gIGNvbnN0IHJhbmRvbURlc3BlZGlkYSA9ICgpID0+IGRlc3BlZGlkYXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGVzcGVkaWRhcy5sZW5ndGgpXTtcblxuICAvLyBNZW5zYWplcyBwcmVkZWZpbmlkb3MgcGFyYSBDbGllbnRlcyB5IE51ZXZvc1xuICBjb25zdCBjbGllbnRlTWVzc2FnZXMgPSBbXG4gICAgYCR7cmFuZG9tSW50cm9kdWN0aW9uKG5hbWUsIHNhbGVzUGVyc29uTmFtZSl9XFxuXFxuQWN0dWFsbWVudGUsIHNhYmVtb3MgcXVlIGVzdMOhcyBwYWdhbmRvIGVsIHByZWNpbyByZWd1bGFyLiDCoVBlcm8gdGVuZW1vcyBwcm9tb2Npb25lcyBwYXJhIHRpISBBcXXDrSB0ZSBkZWpvIGFsZ3VuYXMgb3BjaW9uZXM6XFxuXFxuJHtzaHVmZmxlZENsaWVudGVzUGFja2FnZXN9XFxuXFxuJHtyYW5kb21EZXNwZWRpZGEoKX1gLFxuICAgIGAke3JhbmRvbUludHJvZHVjdGlvbihuYW1lLCBzYWxlc1BlcnNvbk5hbWUpfVxcblxcbkhlbW9zIHJldmlzYWRvIHR1IGN1ZW50YSB5IHBvZGVtb3Mgb2ZyZWNlcnRlIGVzdGFzIHByb21vY2lvbmVzOlxcblxcbiR7c2h1ZmZsZWRDbGllbnRlc1BhY2thZ2VzfVxcblxcbiR7cmFuZG9tRGVzcGVkaWRhKCl9YCxcbiAgICBgJHtyYW5kb21JbnRyb2R1Y3Rpb24obmFtZSwgc2FsZXNQZXJzb25OYW1lKX1cXG5cXG7CoU5vIHRlIHBpZXJkYXMgbnVlc3RyYXMgbnVldmFzIG9mZXJ0YXMhIEFxdcOtIHRlIGRlam8gbGFzIG9wY2lvbmVzIGRpc3BvbmlibGVzOlxcblxcbiR7c2h1ZmZsZWRDbGllbnRlc1BhY2thZ2VzfVxcblxcbiR7cmFuZG9tRGVzcGVkaWRhKCl9YCxcbiAgXTtcblxuICBjb25zdCBudWV2b3NNZXNzYWdlcyA9IFtcbiAgICBgJHtyYW5kb21JbnRyb2R1Y3Rpb24obmFtZSwgc2FsZXNQZXJzb25OYW1lKX1cXG5cXG5Fc3RhbW9zIGVtb2Npb25hZG9zIGRlIG9mcmVjZXJ0ZSBlc3RhcyBwcm9tb2Npb25lcyBleGNsdXNpdmFzOlxcblxcbiR7c2h1ZmZsZWROdWV2b3NQYWNrYWdlc31cXG5cXG4ke3JhbmRvbURlc3BlZGlkYSgpfWAsXG4gICAgYCR7cmFuZG9tSW50cm9kdWN0aW9uKG5hbWUsIHNhbGVzUGVyc29uTmFtZSl9XFxuXFxuwqFUZSB0ZW5lbW9zIHVuYSBvZmVydGEgZXNwZWNpYWwhIEFxdcOtIHRpZW5lcyBudWVzdHJhcyBwcm9tb2Npb25lczpcXG5cXG4ke3NodWZmbGVkTnVldm9zUGFja2FnZXN9XFxuXFxuJHtyYW5kb21EZXNwZWRpZGEoKX1gLFxuICAgIGAke3JhbmRvbUludHJvZHVjdGlvbihuYW1lLCBzYWxlc1BlcnNvbk5hbWUpfVxcblxcbk5vcyBlbmNhbnRhcsOtYSBxdWUgYXByb3ZlY2hlcyBudWVzdHJhcyBvZmVydGFzLiBBcXXDrSB0aWVuZXMgbGFzIG9wY2lvbmVzOlxcblxcbiR7c2h1ZmZsZWROdWV2b3NQYWNrYWdlc31cXG5cXG4ke3JhbmRvbURlc3BlZGlkYSgpfWAsXG4gIF07XG5cbiAgLy8gU2VsZWNjaW9uYSBhbGVhdG9yaWFtZW50ZSB1biBtZW5zYWplIGRlIGxvcyBhcnJheXMgcHJlZGVmaW5pZG9zXG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlICdDbGllbnRlcyc6XG4gICAgICByZXR1cm4gY2xpZW50ZU1lc3NhZ2VzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNsaWVudGVNZXNzYWdlcy5sZW5ndGgpXTtcbiAgICBjYXNlICdOdWV2b3MnOlxuICAgICAgcmV0dXJuIG51ZXZvc01lc3NhZ2VzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51ZXZvc01lc3NhZ2VzLmxlbmd0aCldO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY2xpZW50ZU1lc3NhZ2VzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNsaWVudGVNZXNzYWdlcy5sZW5ndGgpXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZVJhbmRvbU9yZGVyIiwicGFja2FnZXMiLCJpIiwibGVuZ3RoIiwiaiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImpvaW4iLCJyYW5kb21CcmFuZE5hbWUiLCJicmFuZFZhcmlhdGlvbnMiLCJyYW5kb21JbnRyb2R1Y3Rpb24iLCJuYW1lIiwic2FsZXNQZXJzb25OYW1lIiwiaW50cm9kdWN0aW9ucyIsImdlbmVyYXRlTWVzc2FnZSIsIm1lc3NhZ2VUeXBlIiwiY3VzdG9tTWVzc2FnZSIsInBhY2thZ2VzQ2xpZW50ZXMiLCJwYWNrYWdlc051ZXZvcyIsInNodWZmbGVkQ2xpZW50ZXNQYWNrYWdlcyIsInNodWZmbGVkTnVldm9zUGFja2FnZXMiLCJkZXNwZWRpZGFzIiwicmFuZG9tRGVzcGVkaWRhIiwiY2xpZW50ZU1lc3NhZ2VzIiwibnVldm9zTWVzc2FnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/generateMessage.ts\n"));

/***/ })

});